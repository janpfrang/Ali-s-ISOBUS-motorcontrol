/*
 * Ali's Motor Controller - Stage 1 Bring-Up
 * 
 * Hardware:
 *   - ESP32 NodeMCU
 *   - KY-040 Rotary Encoder (CLK=27, DT=26, SW=25)
 *   - I2C 20x4 LCD Display (SDA=13, SCL=14)
 *   - MOSFET driver PWM output (PWM=15, 10kHz)
 *   - Reed sensor for wheel speed (GPIO19)
 *   - Inductive sensor via PCF817 optocoupler (GPIO23)
 *   - [Stage 2] CAN transceiver SN65HVD230 (TX=22, RX=21)
 *
 * Modes:
 *   - AUTO:   PWM proportional to speed (0 km/h=0%, 20 km/h=100%)
 *   - MANUAL: PWM set by rotary encoder (0-100%)
 *
 * Speed sources:
 *   - REED: 1 pulse per wheel revolution (410mm wheel)
 *   - IND:  Inductive sensor, 7.77 pulses per meter
 *
 * Controls:
 *   - Short press:  START / STOP
 *   - Double press: Switch speed sensor (REED <-> IND)
 *   - Long press (>1s): Switch AUTO <-> MANUAL
 *   - Rotate: Adjust PWM % (MANUAL mode only)
 */

#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// ─── Pin Definitions ─────────────────────────────────────────
#define PIN_SDA       13
#define PIN_SCL       14

#define PIN_ENC_CLK   27
#define PIN_ENC_DT    26
#define PIN_ENC_SW    25

#define PIN_PWM       15

#define PIN_REED      19
#define PIN_INDUCTIVE 23      // Inductive sensor via PCF817 optocoupler

// ─── Stage 2 Pins (reserved, not yet used) ──────────────────
#define PIN_CAN_TX    22
#define PIN_CAN_RX    21
// PIN_LIFT_IN: TBD — needs own GPIO, separate from PIN_INDUCTIVE

// ─── PWM Configuration ──────────────────────────────────────
#define PWM_FREQ      10000   // 10 kHz
#define PWM_RESOLUTION 8      // 8-bit (0-255)

// ─── Wheel Configuration ────────────────────────────────────
// >>> SET THIS TO YOUR WHEEL DIAMETER IN mm <<<
#define WHEEL_DIAMETER_MM  410

// Circumference in meters: pi * d
const float wheelCircumM = (float)WHEEL_DIAMETER_MM / 1000.0 * PI;

// ─── Inductive Sensor Configuration ─────────────────────────
// Pulses per meter of ground travel
#define INDUCTIVE_PULSES_PER_M  7.77

// ─── Auto Mode Configuration ────────────────────────────────
#define AUTO_MAX_SPEED_KMH  20.0

// ─── LCD (address 0x27 is most common, try 0x3F if not working) ─
LiquidCrystal_I2C lcd(0x27, 20, 4);

// ─── Mode / State ───────────────────────────────────────────
enum Mode { MODE_MANUAL, MODE_AUTO };
enum SpeedSource { SRC_REED, SRC_INDUCTIVE };

Mode currentMode = MODE_MANUAL;
SpeedSource speedSource = SRC_REED;
bool motorRunning = false;

// ─── Encoder State ──────────────────────────────────────────
volatile int  pwmPercent     = 0;       // 0 - 100 (manual)
volatile bool encoderChanged = false;
volatile int  lastEncCLK     = HIGH;

// ─── Button State ───────────────────────────────────────────
bool     buttonDown       = false;
unsigned long buttonDownTime  = 0;
bool     longPressHandled = false;
const unsigned long longPressMs = 1000;       // 1 second for long press
const unsigned long debounceDelay = 50;       // ms
const unsigned long doublePressMs = 400;      // max gap between double press
unsigned long lastButtonChange = 0;
unsigned long lastReleaseTime  = 0;
bool     waitingSecondPress = false;
bool     startStopPending   = false;

// ─── Reed Sensor State ──────────────────────────────────────
volatile unsigned long reedLastPulseUs = 0;
volatile unsigned long reedPeriodUs    = 0;

// ─── Inductive Sensor State ─────────────────────────────────
volatile unsigned long indLastPulseUs = 0;
volatile unsigned long indPeriodUs    = 0;

// ─── Timing ─────────────────────────────────────────────────
unsigned long startTime = 0;
unsigned long lastDisplayUpdate = 0;
const unsigned long displayInterval = 250;

// Speed goes to 0 if no pulse within this timeout
const unsigned long sensorTimeoutUs = 2000000; // 2 seconds

// ─── Encoder ISR ─────────────────────────────────────────────
void IRAM_ATTR encoderISR() {
  int clkState = digitalRead(PIN_ENC_CLK);
  int dtState  = digitalRead(PIN_ENC_DT);

  if (clkState != lastEncCLK && clkState == LOW) {
    if (dtState != clkState) {
      if (pwmPercent < 100) pwmPercent++;
    } else {
      if (pwmPercent > 0) pwmPercent--;
    }
    encoderChanged = true;
  }
  lastEncCLK = clkState;
}

// ─── Reed Sensor ISR ─────────────────────────────────────────
void IRAM_ATTR reedISR() {
  unsigned long now = micros();
  unsigned long elapsed = now - reedLastPulseUs;

  // Debounce: ignore pulses faster than 5ms
  if (elapsed < 5000) return;

  reedPeriodUs = elapsed;
  reedLastPulseUs = now;
}

// ─── Inductive Sensor ISR ────────────────────────────────────
void IRAM_ATTR inductiveISR() {
  unsigned long now = micros();
  unsigned long elapsed = now - indLastPulseUs;

  // Debounce: ignore pulses faster than 2ms (~500 Hz max)
  if (elapsed < 2000) return;

  indPeriodUs = elapsed;
  indLastPulseUs = now;
}

// ─── Get Speed in km/h (from reed sensor) ───────────────────
float getSpeedReed() {
  unsigned long period;
  unsigned long lastPulse;

  noInterrupts();
  period    = reedPeriodUs;
  lastPulse = reedLastPulseUs;
  interrupts();

  if (period == 0) return 0.0;
  if ((micros() - lastPulse) > sensorTimeoutUs) return 0.0;

  // 1 pulse per revolution
  float rps = 1000000.0 / (float)period;
  float ms = rps * wheelCircumM;
  float kmh = ms * 3.6;
  if (kmh > 40.0) return 0.0;
  return kmh;
}

// ─── Get Speed in km/h (from inductive sensor) ──────────────
float getSpeedInductive() {
  unsigned long period;
  unsigned long lastPulse;

  noInterrupts();
  period    = indPeriodUs;
  lastPulse = indLastPulseUs;
  interrupts();

  if (period == 0) return 0.0;
  if ((micros() - lastPulse) > sensorTimeoutUs) return 0.0;

  // 7.77 pulses per meter → distance per pulse = 1/7.77 m
  float pulsesPerSec = 1000000.0 / (float)period;
  float ms = pulsesPerSec / INDUCTIVE_PULSES_PER_M;  // m/s
  float kmh = ms * 3.6;
  if (kmh > 40.0) return 0.0;
  return kmh;
}

// ─── Get Speed from active source ────────────────────────────
float getSpeedKmh() {
  if (speedSource == SRC_REED) {
    return getSpeedReed();
  } else {
    return getSpeedInductive();
  }
}

// ─── Get Active PWM % ───────────────────────────────────────
int getActivePwmPercent() {
  if (!motorRunning) return 0;

  if (currentMode == MODE_MANUAL) {
    return pwmPercent;
  } else {
    float kmh = getSpeedKmh();
    float pct = (kmh / AUTO_MAX_SPEED_KMH) * 100.0;
    if (pct < 0.0) pct = 0.0;
    if (pct > 100.0) pct = 100.0;
    return (int)pct;
  }
}

// ─── Apply PWM ───────────────────────────────────────────────
void applyPWM() {
  int pct = getActivePwmPercent();
  uint32_t duty = map(pct, 0, 100, 0, 255);
  ledcWrite(PIN_PWM, duty);
}

// ─── Update Display ──────────────────────────────────────────
void updateDisplay() {
  char line[21];

  // Row 0: Mode + sensor source
  const char* modeStr   = (currentMode == MODE_AUTO) ? "AUTO" : "MANU";
  const char* sensorStr = (speedSource == SRC_REED) ? "REED" : "IND";
  snprintf(line, sizeof(line), "Ali [%-4s] spd:%-4s ", modeStr, sensorStr);
  lcd.setCursor(0, 0);
  lcd.print(line);

  // Row 1: PWM output %
  int activePwm = getActivePwmPercent();
  if (currentMode == MODE_MANUAL) {
    snprintf(line, sizeof(line), "PWM: %3d%%           ", activePwm);
  } else {
    snprintf(line, sizeof(line), "PWM: %3d%% (auto)    ", activePwm);
  }
  lcd.setCursor(0, 1);
  lcd.print(line);

  // Row 2: Speed
  float kmh = getSpeedKmh();
  char speedStr[8];
  dtostrf(kmh, 5, 1, speedStr);
  snprintf(line, sizeof(line), "Speed:%s km/h   ", speedStr);
  lcd.setCursor(0, 2);
  lcd.print(line);

  // Row 3: State + uptime
  unsigned long seconds = (millis() - startTime) / 1000;
  unsigned long mins = seconds / 60;
  unsigned long secs = seconds % 60;
  if (motorRunning) {
    snprintf(line, sizeof(line), "RUN  %4lu:%02lu        ", mins, secs);
  } else {
    snprintf(line, sizeof(line), "STOP %4lu:%02lu        ", mins, secs);
  }
  lcd.setCursor(0, 3);
  lcd.print(line);
}

// ─── Execute Start/Stop ──────────────────────────────────────
void doStartStop() {
  motorRunning = !motorRunning;
  applyPWM();
  Serial.print("Motor ");
  Serial.println(motorRunning ? "STARTED" : "STOPPED");
}

// ─── Execute Sensor Switch ───────────────────────────────────
void doSensorSwitch() {
  if (speedSource == SRC_REED) {
    speedSource = SRC_INDUCTIVE;
  } else {
    speedSource = SRC_REED;
  }
  applyPWM();
  Serial.print("Sensor: ");
  Serial.println(speedSource == SRC_REED ? "REED" : "INDUCTIVE");
}

// ─── Handle Button (short / double / long press) ────────────
void handleButton() {
  bool raw = digitalRead(PIN_ENC_SW);
  unsigned long now = millis();

  // Debounce
  if ((now - lastButtonChange) < debounceDelay) return;

  // Button just pressed
  if (raw == LOW && !buttonDown) {
    buttonDown = true;
    buttonDownTime = now;
    longPressHandled = false;
    lastButtonChange = now;

    // Check if this is the second press of a double-press
    if (waitingSecondPress && (now - lastReleaseTime) <= doublePressMs) {
      // ── Double press: switch sensor ──
      doSensorSwitch();
      waitingSecondPress = false;
      startStopPending = false;
      longPressHandled = true;  // prevent long press from also firing
    }
  }

  // Button held — check for long press
  if (raw == LOW && buttonDown && !longPressHandled) {
    if ((now - buttonDownTime) >= longPressMs) {
      // ── Long press: switch mode ──
      if (currentMode == MODE_AUTO) {
        currentMode = MODE_MANUAL;
      } else {
        currentMode = MODE_AUTO;
      }
      longPressHandled = true;
      waitingSecondPress = false;
      startStopPending = false;
      applyPWM();

      Serial.print("Mode: ");
      Serial.println(currentMode == MODE_AUTO ? "AUTO" : "MANUAL");
    }
  }

  // Button released
  if (raw == HIGH && buttonDown) {
    buttonDown = false;
    lastButtonChange = now;

    if (!longPressHandled) {
      // First short press — wait for possible second press
      if (!waitingSecondPress) {
        waitingSecondPress = true;
        startStopPending = true;
        lastReleaseTime = now;
      }
    }
  }

  // Timeout: if waiting for second press and it didn't come, execute start/stop
  if (waitingSecondPress && !buttonDown && startStopPending) {
    if ((now - lastReleaseTime) > doublePressMs) {
      doStartStop();
      waitingSecondPress = false;
      startStopPending = false;
    }
  }
}

// ─── Setup ───────────────────────────────────────────────────
void setup() {
  Serial.begin(115200);
  Serial.println("Ali's Motor Controller - Stage 1 Bring-Up");

  // I2C on custom pins
  Wire.begin(PIN_SDA, PIN_SCL);

  // LCD init
  lcd.init();
  lcd.backlight();

  // Encoder pins
  pinMode(PIN_ENC_CLK, INPUT_PULLUP);
  pinMode(PIN_ENC_DT,  INPUT_PULLUP);
  pinMode(PIN_ENC_SW,  INPUT_PULLUP);

  lastEncCLK = digitalRead(PIN_ENC_CLK);
  attachInterrupt(digitalPinToInterrupt(PIN_ENC_CLK), encoderISR, CHANGE);

  // Reed sensor pin
  pinMode(PIN_REED, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(PIN_REED), reedISR, FALLING);

  // Inductive sensor pin (PC817 module has onboard pull-up)
  pinMode(PIN_INDUCTIVE, INPUT);
  attachInterrupt(digitalPinToInterrupt(PIN_INDUCTIVE), inductiveISR, FALLING);

  // PWM setup (ESP32 Core 3.x API)
  ledcAttach(PIN_PWM, PWM_FREQ, PWM_RESOLUTION);
  ledcWrite(PIN_PWM, 0);

  startTime = millis();
  updateDisplay();

  Serial.println("Setup complete.");
  Serial.print("Wheel: ");
  Serial.print(WHEEL_DIAMETER_MM);
  Serial.print("mm, circumference: ");
  Serial.print(wheelCircumM, 3);
  Serial.println("m");
  Serial.print("Inductive: ");
  Serial.print(INDUCTIVE_PULSES_PER_M);
  Serial.println(" pulses/m");
  Serial.println("Short: START/STOP | Double: sensor | Long: AUTO/MANUAL");
}

// ─── Loop ────────────────────────────────────────────────────
void loop() {
  // ── Handle button (short/double/long press) ──
  handleButton();

  // ── Handle encoder rotation (MANUAL mode PWM adjustment) ──
  if (encoderChanged) {
    encoderChanged = false;
    if (currentMode == MODE_MANUAL) {
      applyPWM();
    }
  }

  // ── AUTO mode: continuously update PWM based on speed ──
  if (currentMode == MODE_AUTO && motorRunning) {
    applyPWM();
  }

  // ── Periodic display refresh ──
  if ((millis() - lastDisplayUpdate) > displayInterval) {
    lastDisplayUpdate = millis();
    updateDisplay();
  }
}
